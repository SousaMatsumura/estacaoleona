#servidor_tornado_camera_3.py__author__ = 'Igor Henrique Camargo, Ana Laura Gonçalves da Silva'__date__ = "$22/08/2017 13:30:00$"__version__ = '1.0'from tornado import websocket, web, ioloop, queues, escape, ioloop, optionsimport json, cv2, base64, logging, multiprocessing, time, os.path, uuid#LIBS LEONAimport settings,video_camera, video_camera_teste, settings, controle_pantilt, comunicacao_serialconfig = settings.Settings(2).get_config()""":variável config (settings.Settings): Lê o arquivo de configuração. Setting(2). Não alterar pois é o que determina qual camera será inicializada"""if config['is_pantilt'] == 'True':    """:if config: Verifica se o controla do pantilt está ativo"""    com = comunicacao_serial.ComunicacaoSerial(config['port_con'], config['baudrate'])    """:método ComunicacaoSerial(): Inicia a classe responsavel pela comunicação serial. Paramêtros: port: Porta de comunicação e baudrate: taxa de transmissão de dados"""    cp = controle_pantilt.ControlePantilt(com)    """:variável cp:  Inicia o classe responsável pelo controle de pantilt"""queue = multiprocessing.Queue(maxsize = 60)""":variável queue: inicia a pilha para armazenar imagens. Paramêtro: maxsize(330)--> Controla o buffer máximo de leitura da câmers, NÃO ALTERAR!, esta variável, junto a de "frames" presente no arquivo de configuração, garante que a sincronia do serviço."""if config['is_test'] == 'True':    """constante config: (booleano) Verifica o modo de inicialização do Servidor Tornado"""    _com = comunicacao_serial.ComunicacaoSerial(config['vc_port_con'], config['vc_baudrate'])    """variável _com: (instância):Inicializa comunicação serial"""    vc = video_camera_teste.VideoCamera(0, queue, _com, config['vc_name_arq'])    """:variável vc: (instância) Inicializa leitura das câmeras"""elif config['is_test'] == 'False':    """constante config: (booleano) Verifica o modo de teste de ser inicializado"""    vc = video_camera.VideoCamera(0, queue)vc.daemon = Truevc.start()#Desliga as câmeras e zera o pantilt quando precisacontrol_teste = '0'control_time = Noneclass SocketHandler(websocket.WebSocketHandler):    #Classe responsável pela transmissão das imagens    global vc, queue    writer = None    def check_origin(self, origin):        return True        def render(self):        """Prepara imagens para transmissão"""        image = ""        frame = queue.get()        #TESTE de resize de imagem        frame =  cv2.resize(frame,(320,240))        """:variável frame: (matrix) Recebe imagens da classe VideoCamera responsável pela leitura das câmeras"""        cnt = cv2.imencode('.jpg',frame)[1]        """:variável cnt: (numpy array) Formata matrix para string"""         b64 = base64.b64encode(cnt)        """:variável b64: (base64) Formata numpy array em dado do tipo basee64"""        cnt = str(b64)        """:variável cnt: Transforma valor lido de bytes para string"""        strcnt = str(cnt[2:])        """:variável strcnt: (string) - Retira duas primeiras letras "b'" para estar no padrão exigido no Tornado"""        image += "<img src='data:image/jpeg;base64,"+ strcnt +"'>"        """:variável image: (string) - Coloca a variavel de base64 no padrão do html"""        try:            self.write_message(image)            """função write_massage: Envia dado para a porta de Ip escolhida"""        except Exception as err:            print("Error sending message: {}".format(err))            logging.error("Error sending message: {}".format(err), exc_info=True)            self.writer.stop()        #Desliga as câmeras e zera o pantilt quando precisa        global control_teste, control_time        hora = time.strftime("%H")                if int(hora) >= 18 and control_time is None or int(hora) >= 18 and control_time is False:            control_time = True        if control_time:            if int(hora) >= 5  and int(hora) <= 6:                global cp                print("Zerando pantilt\n Desligando câmeras")                                cp.desligarcamera()                cp.azimute(int('0'))                cp.elevacao(int('-35'))                control_time = False    def open(self):        """Inicia o envio de dados"""        interval = 1000/config['frames']        """constante interval: (inteiro) Determina taxa de envio dos dados"""        self.writer = ioloop.PeriodicCallback(self.render, interval)        self.writer.start()    def on_close(self):        logging.info('Closing connection')        self.writer.stop()class ControlBox(websocket.WebSocketHandler):    #Classe responsável por receber controle de gravação das câmeras e movimento do pantilt    global vc,cp    #PANTILT    azimute = 0    elevacao = -35    #Câmeras    record = None    control_record = 'disponivel'    camera = None    control_camera = 'desligada'    estado_estacao = 'ONLINE'        waiters = set()    cache = []    cache_size = 200    def check_origin(self, origin):        return True        def get_compression_options(self):        return {}    def open(self):        """Cria .json inicial para atualizar status de controle e gravação para o servidor"""        ControlBox.waiters.add(self)        chat = {            "id": str(uuid.uuid4()),            "azimute": ControlBox.azimute,            "elevacao": ControlBox.elevacao,            "gravar": ControlBox.control_record,            "camera": ControlBox.control_camera,            "estadoEstacao": ControlBox.estado_estacao,            }        self.write_message(chat)    def on_close(self):        ControlBox.waiters.remove(self)    @classmethod    def update_cache(cls, chat):        cls.cache.append(chat)        if len(cls.cache) > cls.cache_size:            cls.cache = cls.cache[-cls.cache_size:]    @classmethod    def send_updates(cls, chat):        logging.info("sending message to %d waiters", len(cls.waiters))        for waiter in cls.waiters:            try:                waiter.write_message(chat)            except:                logging.error("Error sending message", exc_info=True)    def on_message(self, message):        logging.info("got message %r", message)        print(message)        parsed = escape.json_decode(message)        """variável parsed: lê a mensagem de controle enviada pelas estações"""        if 'azimute' in parsed:#Verifica se existe comando para mudança de azimute            ControlBox.azimute = parsed['azimute']            cp.azimute(int(ControlBox.azimute))        if 'elevacao' in parsed:#Verifica se existe comando para mudança de elevacao            ControlBox.elevacao = parsed['elevacao']            el = int(ControlBox.elevacao)            print(el)            cp.elevacao(el)        if 'gravar' in parsed:#Verifica se existe comando para iniciar/parar gravação            ControlBox.record = parsed['gravar']            if ControlBox.record == 'True': # Inicia gravação                vc.start_record()                ControlBox.control_record = 'gravando' #Variável de controle para o servidor            elif ControlBox.record == 'False' and  ControlBox.control_record == 'gravando': # Finaliza gravação                vc.stop_record()                            ControlBox.control_record = 'disponivel'#Variável de controle para o servidor         if config['is_pantilt'] == 'True':#(booleano): Verifica se o controla do pantilt está ativo            if 'camera' in parsed:#Verifica se existe comando para Ligar/Desligar câmeras                ControlBox.camera = parsed['camera']                if ControlBox.camera == 'True':                    cp.ligarcamera()                    ControlBox.control_camera = 'ligada'                elif ControlBox.camera == 'False':                    cp.desligarcamera()                    ControlBox.control_camera = 'desligada'        chat = {            "id": str(uuid.uuid4()),            "azimute": ControlBox.azimute,            "elevacao": ControlBox.elevacao,            "gravar": ControlBox.control_record,            "camera": ControlBox.control_camera,            "estadoEstacao": ControlBox.estado_estacao,            }        """variavel chat: (.json) reescreve .json para atualizar status de controle e gravação para o servidor"""        ControlBox.update_cache(chat)        ControlBox.send_updates(chat)app = web.Application([    (r'/ws', SocketHandler),    (r'/controlbox', ControlBox),])if __name__ == '__main__':    print('[DEBUG] Video Capture Camera 3: ' + str(vc))    print('***********************************************')    print('*                                             *')    print('*            NÃO FECHE ESTA JANELA!           *')    print('*                                             *')    print('***********************************************')##    if config['is_pantilt'] == 'True':#(booleano): Verifica se o controla do pantilt está ativo##        time.sleep(3)# Tempo para esperar inicialização do hardware##        cp.resetarazimute()#Coloca o pantilt em 0º grau na horizontal##        cp.resetarelevacao()#Coloca o pantilt em -35º graus na vertical    app.listen(config['port_listen'])#(string) - Recebe a porta do IP para enviar dados    ioloop.IOLoop.current().start() #Inicia o Servidor Tornado